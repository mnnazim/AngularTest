import { ViewportRuler } from '@angular/cdk/scrolling';
import { Directive, ElementRef, NgZone, ChangeDetectorRef, Component, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { Subject, merge } from 'rxjs';
import { filter, map, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { trigger, transition, style, animate } from '@angular/animations';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/scrolling';

const _c0 = ["*"];
class NgxNavbarDynamicExpandDirective {
    /**
     * @param {?} _viewportRuler
     * @param {?} _elRef
     * @param {?} _ngZone
     * @param {?} _cdRef
     */
    constructor(_viewportRuler, _elRef, _ngZone, _cdRef) {
        this._viewportRuler = _viewportRuler;
        this._elRef = _elRef;
        this._ngZone = _ngZone;
        this._cdRef = _cdRef;
        this._isExpanded = false;
        this._onDestroy = new Subject();
        this._update = new Subject();
        this.isExpanded$ = merge(this._viewportRuler.change(150), this._update).pipe(filter((/**
         * @return {?}
         */
        () => checkBootstrapStylesAreLoaded(this._elRef.nativeElement))), map((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const element = this._elRef.nativeElement;
            /** @type {?} */
            let overflowSize;
            if (this.isExpanded) {
                overflowSize = element.scrollWidth - element.offsetWidth;
            }
            else {
                /** @type {?} */
                const clone = (/** @type {?} */ (element.cloneNode(true)));
                clone.classList.add('navbar-expand');
                element.parentElement.appendChild(clone);
                overflowSize = clone.scrollWidth - clone.offsetWidth;
                element.parentElement.removeChild(clone);
            }
            if (!overflowSize) {
                return true;
            }
        })), distinctUntilChanged(), takeUntil(this._onDestroy));
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.isExpanded$.subscribe((/**
             * @param {?} isExpanded
             * @return {?}
             */
            (isExpanded) => {
                this._ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    this._isExpanded = isExpanded;
                    this._cdRef.markForCheck();
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    get isExpanded() {
        return this._isExpanded;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (checkBootstrapStylesAreLoaded(this._elRef.nativeElement)) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.updateExpansion();
                }), 0);
            }
            else {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.ngAfterContentInit();
                }), 1000 / 60);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._update.complete();
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * @return {?}
     */
    updateExpansion() {
        this._update.next();
    }
}
NgxNavbarDynamicExpandDirective.ɵfac = function NgxNavbarDynamicExpandDirective_Factory(t) { return new (t || NgxNavbarDynamicExpandDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgxNavbarDynamicExpandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxNavbarDynamicExpandDirective, selectors: [["", "ngxNavbarDynamicExpand", ""]], hostAttrs: [1, "navbar", "text-nowrap"], hostVars: 2, hostBindings: function NgxNavbarDynamicExpandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("navbar-expand", ctx.isExpanded);
    } } });
/** @nocollapse */
NgxNavbarDynamicExpandDirective.ctorParameters = () => [
    { type: ViewportRuler },
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxNavbarDynamicExpandDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxNavbarDynamicExpand]',
                host: {
                    class: 'navbar text-nowrap',
                    '[class.navbar-expand]': 'isExpanded'
                }
            }]
    }], function () { return [{ type: ɵngcc1.ViewportRuler }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._isExpanded;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._onDestroy;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._update;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype.isExpanded$;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._viewportRuler;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._elRef;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarDynamicExpandDirective.prototype._cdRef;
}
/**
 * @param {?} element
 * @return {?}
 */
function checkBootstrapStylesAreLoaded(element) {
    /** @type {?} */
    const computedStyle = getComputedStyle(element);
    return computedStyle && computedStyle.whiteSpace === 'nowrap';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Time and timing curve for navbar animations.
 * @type {?}
 */
const NAVBAR_ANIMATION_TIMING = '300ms ease-out';
/** @type {?} */
const ngxNavbarAnimations = {
    navbarSlide: trigger('slideState', [
        transition('false => true', [
            style({
                opacity: 0,
                height: 0,
                overflow: 'hidden'
            }),
            animate(NAVBAR_ANIMATION_TIMING, style({
                opacity: 1,
                height: '*'
            }))
        ]),
        transition('true => false', [
            animate(NAVBAR_ANIMATION_TIMING, style({
                display: 'block',
                opacity: 0,
                height: 0,
                overflow: 'hidden'
            }))
        ])
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxNavbarCollapseComponent {
    /**
     * @param {?} _cdr
     */
    constructor(_cdr) {
        this._cdr = _cdr;
        this.isCollapsed = true;
        this.isTransitioning = false;
    }
    /**
     * @return {?}
     */
    toggle() {
        this.isTransitioning = true;
        this.isCollapsed = !this.isCollapsed;
        this._cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    close() {
        if (this.isCollapsed) {
            return;
        }
        this.isTransitioning = true;
        this.isCollapsed = true;
        this._cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    open() {
        if (!this.isCollapsed) {
            return;
        }
        this.isTransitioning = true;
        this.isCollapsed = false;
        this._cdr.markForCheck();
    }
}
NgxNavbarCollapseComponent.ɵfac = function NgxNavbarCollapseComponent_Factory(t) { return new (t || NgxNavbarCollapseComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgxNavbarCollapseComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxNavbarCollapseComponent, selectors: [["ngx-navbar-collapse"]], hostAttrs: [1, "navbar-collapse", "ngx-navbar-collapse"], hostVars: 7, hostBindings: function NgxNavbarCollapseComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@slideState.done", function NgxNavbarCollapseComponent_animation_slideState_done_HostBindingHandler() { return ctx.isTransitioning = false; });
    } if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@slideState", !ctx.isCollapsed);
        ɵngcc0.ɵɵclassProp("collapse", !ctx.isTransitioning)("show", !ctx.isCollapsed && !ctx.isTransitioning)("collapsing", ctx.isTransitioning);
    } }, exportAs: ["ngxNavbarCollapse"], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NgxNavbarCollapseComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["\n      .ngx-navbar-collapse.collapsing {\n        height: auto;\n      }\n    "], encapsulation: 2, data: { animation: [ngxNavbarAnimations.navbarSlide] }, changeDetection: 0 });
/** @nocollapse */
NgxNavbarCollapseComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxNavbarCollapseComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-navbar-collapse',
                template: `
    <ng-content></ng-content>
  `,
                host: {
                    class: 'navbar-collapse ngx-navbar-collapse',
                    '[class.collapse]': '!isTransitioning',
                    '[class.show]': '!isCollapsed && !isTransitioning',
                    '[class.collapsing]': 'isTransitioning',
                    '[@slideState]': '!isCollapsed',
                    '(@slideState.done)': 'isTransitioning = false'
                },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [ngxNavbarAnimations.navbarSlide],
                exportAs: 'ngxNavbarCollapse',
                styles: [`
      .ngx-navbar-collapse.collapsing {
        height: auto;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
if (false) {
    /** @type {?} */
    NgxNavbarCollapseComponent.prototype.isCollapsed;
    /** @type {?} */
    NgxNavbarCollapseComponent.prototype.isTransitioning;
    /**
     * @type {?}
     * @private
     */
    NgxNavbarCollapseComponent.prototype._cdr;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxNavbarModule {
}
NgxNavbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxNavbarModule });
NgxNavbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxNavbarModule_Factory(t) { return new (t || NgxNavbarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxNavbarModule, { declarations: function () { return [NgxNavbarCollapseComponent, NgxNavbarDynamicExpandDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgxNavbarCollapseComponent, NgxNavbarDynamicExpandDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxNavbarModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxNavbarCollapseComponent, NgxNavbarDynamicExpandDirective],
                imports: [CommonModule],
                exports: [NgxNavbarCollapseComponent, NgxNavbarDynamicExpandDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NAVBAR_ANIMATION_TIMING, NgxNavbarCollapseComponent, NgxNavbarDynamicExpandDirective, NgxNavbarModule, ngxNavbarAnimations };

//# sourceMappingURL=ngx-bootstrap-navbar.js.map